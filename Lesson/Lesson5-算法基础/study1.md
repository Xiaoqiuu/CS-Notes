算法基础
=========
For LanQiao
----------

[TOC]

# 1. 时间复杂度

## 1.1 时间复杂度

- 时间复杂度是衡量算法执行时间随着输入规模增长的增长率。
- 通过分析算法中基本操作(原子操作)的执行次数来确定时间复杂度。
- 常见的时间复杂度
  - 常数时间 $O(1)$
  - 线性时间 $O(n)$
  - 对数时间 $O(log n)$
  - 平方时间 $O(n^2)$
- 计算的时候，关注点是复杂度的数量级，并不要求严格的表达式

一般情况下，关注的是最坏时间复杂度，用$O(f(n))$来表示，大多数情况下仅需要**估算**即可。

> 一般情况下，评测机一秒可以跑2e8次运算，所以要尽可能地让程序运算规模数量控制在1e8以内。
> 举个例子：n = 1e4 $O(n^2)$ = 1e8

蓝桥的时间复杂度考虑$1e8$

## 1.2 空间复杂度

- 空间复杂度是衡量算法执行过程中所需的存储空间随输入规模增长的增长率
- 通过分析算法中所使用的额外存储空间的大小来确定空间复杂度
- 常见的空间复杂度
  - 常数空间 $O(1)$
  - 线性空间 $O(n)$
  - 对数空间 $O(log n)$
  - 平方空间 $O(n^2)$



一般情况下，关注的是最坏空间复杂度，用$O(f(n))$来表示，大多数时候程序占用的空间一般可以根据开的数组大小精确算出，但也存在需要估算的情况。题目一般不会卡空间，一般是卡时间。

> 举个例子，假设题目限制128MB，1int\~32bit\~4Bytes，128MB\~3e7int

## 1.3 分析技巧

1. 理解基本操作： 基本操作可以是算术运算（加法、乘法、位运算等等）、比较操作、赋值操作等。一般称之为**原子操作**（时间复杂度$O(1)$）。
2. 关注循环结构：循环是算法中常见的结构，它的执行次数对于时间复杂度的分析至关重要。
   举个例子，for()执行n次，则时间复杂度为$O(n)$，如果里面再嵌套一个for则时间复杂度为$O(n^2)$。
3. 递归算法：递归算法的时间和空间复杂度分析相对复杂。需要确定递归的深度以及每个递归调用的时间和空间的开销。
   可以绘制递归树。
4. 最快情况分析：对于时间复杂度的分析，通常考虑最坏情况下的执行时间。需要考虑输入数据使得算法时间达到最大值的情况。
5. 善用结论：某些常见算法的时间和空间复杂度已经被广泛研究与证明。可以利用这些已知结果来分析算法的复杂度。

```cpp{.line-numbers}
#include <iostream>
#include <vector>
using namespace std;

int calculateSum(vector<int>& nums)
{
    int sum = 0;
    for (int num : nums)
    {
        sum += num;
    }
    return sum;
}

int main()
{
    int n;
    cout << "Enter the number of elements: ";
    cin >> n;

    vector<int> nums(n);
    cout << "Enter the elements: ";
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i];
    }
    int sum = calculateSum(nums);
    cout << "Sum of the elements: " << sum << endl;

    return 0;
}
```
时间复杂度$O(n)$
该算法通过循环遍历数组中的每个元素，并对它们求和，因此时间复杂度与数组中的元素数量成正比。

空间复杂度$O(n)$
算法使用了一个大小为n的向量来存储输入元素，所以空间复杂度与输入元素的数量成正比。

## 1.4 渐进符号\*
渐进符号是函数的阶的规范描述。简单来说，渐进符号忽略了一个函数中增长较慢的部分以及各项的系数（在时间复杂度相关分析中，系数一般被称作「常数」），而保留了可以用来表明该函数增长趋势的重要部分。
$\Theta$定义了一种精确的渐近行为（exact asymptotic behavior）

# 2. 枚举

## 2.1 枚举算法介绍
枚举算法是一种基本算法思想，它通过穷举所有可能的情况来解决问题。它的基本思想是**将问题的解空间中的每个可能的解都枚举出来，并进行验证和比较**，找到满足问题条件的最优解或者所有解。
枚举算法适用于问题规模较小、解空间可穷举的情况。优点：简单直观，易于实现。但是由于需要穷举所有可能的情况，对于问题规模较大的情况，枚举算法的时间复杂度会非常高，效率较低。

## 2.2 解空间的类型
解空间可以是*一个范围内*的所有数字（或二元组、字符串等数据），或者满足某个条件的所有数字。
当然也可以是解空间树，一般可分为子集树和排列树，针对解空间树，需要使用回溯法进行枚举。（后面搜索会讲到）
目前仅使用循环去暴力枚举解空间，具体的解空间类型需要根据题目来理解构造。

## 2.3 循环枚举解空间
1. 首先确定解空间的维度，即问题中需要枚举的变量个数。
2. 对于每个变量，确定其可能的取值范围。这些范围可以根据问题的性质和约束条件来确定。这一步往往是时间复杂度优化的关键。
3. 在循环体内，针对每个可能解进行处理，可以进行问题的验证、计算、输出等操作。


来点小李子:

LanQiaoOJ191：输入一个整数n，1到n中，包含2，0（前导0不算），1，9这样的数总和是多少？

```cpp{.line-numbers}
#include <bits/stdc++.h>
using namespace std;

bool f(int x){
  while(x){
  int y = x % 10;
  if(y == 2 || y == 0|| y == 1 || y == 9 )return true;
  x /= 10;
  }
  return false;
}

int main()
{
  // 请在此输入您的代码
  int n;cin >> n;
  int ans = 0;
  for(int i = 1; i <= n; ++ i){
    if(f(i))ans += i;
  }
  cout << ans << endl;
  return 0;
}
```

# 3. 模拟

> 模拟算法是指模拟实际情况来解决问题，特点是*容易理解但是实现起来复杂*。
> 一般不会涉及太难的题，由较多的简单但是不好处理的部分组成，主打一个考察细心和逻辑思维。
>一般为了使逻辑清晰一些，经常会写比较多的小函数来帮助解题。

模拟算法写的很暴力，一般不卡时间复杂度。

# 4. 递归

递归，指**函数直接或间接调用自身的过程**。

基本情况(递归终止条件): 递归函数中的一个条件，当满足该条件时，递归终止，避免无限递归。可以理解为直接解决极小规模问题的方法。

递归表达式(递归调用): 递归函数中的语句，用于解决规模更小的问题，再将子问题的答案合并成为当前问题的答案。

## 4.1 递归的实现

递归的基本结构如下:

```cpp
返回类型 函数名(参数列表){
    //基本情况 (递归终止条件)
    if (满足终止条件){
        //返回终止条件下的结果
    }
    //递归表达式 (递归调用)
    else {
        //将问题分解为规模更小的子问题
        //使用递归调用解决子问题
        //返回子问题的结果
    }
}

```

## 4.2 递归和循环的比较

# 5. 进制转换

## 5.1 进制的本质

一个十进制的数字，拿`521`举个栗子,其本质就是每一个数位上的数字乘上这一位上的权重(个位的权重就是$10^0$，十位的权重就是$10^1$，百位的权重就是$10^2$，以此类推)。

那么`521`~~这个破数字~~我们就可以拆成：

&emsp;&emsp;&emsp;$521 = (5 \times 10^2) + (2 \times 10^1) + (1 \times 10^0)$

二进制就是把`10`换成了`2`，在计算机中，数字均通过二进制补码来表示。

## 5.2 任意进制转换为十进制

假设给了一个数组来表示一个`K`进制(假设K > 10)的整数。

<img src = "C:\Archive\LanQiao\Lesson\Pictures\0009.png">
实现代码如下：

```cpp{.line-numbers}
ll x = 0;
for(int i = 1; i < n; i++){
    x = x * K + a[i];
  }
cout << x << endl;
```

# 6. 前缀

> 前缀和是一种预处理算法，可以大大降低时间复杂度。

# 7. 差分



# 8. 离散化

> 离散化是一种数据处理的技巧，本质上可以看成是一种**哈希**，其保证数据在哈希以后仍然保持原来的**全/偏序**关系。
> 通俗地讲就是当有些数据因为本身很大或者类型不支持，自身无法作为数组的下标来方便地处理，而影响最终结果的只有元素之间的相对大小关系时，我们可以将原来的数据按照排名来处理问题，即离散化。
> 用来离散化的可以是大整数、浮点数、字符串等等。
> (以上内容摘自OI WIKI)

# 9. 贪心

通过局部最优来获得全局最优解。

```cpp{.line-numbers}
#include<bits/stdc++.h>

using namespace std;
```

# 10. 双指针

> 双指针通过引用两个指针同向移动或双向移动来实现对数据的操作。

# 11. 二分

# 12. 倍增

# 13. 构造

# 14. 位运算